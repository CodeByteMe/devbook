# RabbitMQ最新2021年面试题附答案解析，大汇总







### 1、rabbitmq的集群

**镜像集群模式**

你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。

好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue


### 2、“dead letter”queue 的用途？

当消息被 RabbitMQ server 投递到 consumer 后，但 consumer 却通过 Basic.Reject进行了拒绝时（同时设置 requeue=false），那么该消息会被放入“dead letter”queue 中。该 queue 可用于排查 message 被 reject 或 undeliver 的原因。


### 3、如何保证RabbitMQ消息的可靠传输？

消息不可靠的情况可能是消息丢失，劫持等原因；

**丢失可能又分为：**

1. 生产者丢失消息
2. 消息队列丢失消息
3. 消费者丢失消息

**生产者丢失消息：**

1. 从生产者弄丢数据来看，RabbitMQ提供了 transaction 机制 和 confirm 模式 来确保生产者不丢失消息；
2. transaction机制： 发送消息前，开启事务（channel.exSelect()），然后发送消息，如果发送过程中出现异常，事务就会回滚（channel.txRollback()），如果发送成功则提交事务（channel.txCommit()）。
3. confirm模式：一般这种模式居多，一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列后；RabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了。

如果RabbitMQ没能处理该消息，则会发送一个Nack消息回来，这样可以进行重试操作。

**消息队列丢失消息：**

1. 针对消息队列丢失数据的情况，一般是开启持久化磁盘的配置：
2. 将队列的持久化标识 durable 设置为 true ， 则代表是一个持久的队列，发送消息的时候讲 deliveryMode=2 这样设置以后，即使RabbitMQ挂了，重启后也能恢复数据。

**消费者丢失消息：**

1. 消费者丢失消息一般是因为采用了自动确认消息模式，改为手动确认消息即可。
2. 消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；如果这时候处理消息失败，就会丢失该消息；
3. 解决方案：处理消息成功后，手动回复确认消息。


### 4、如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？

**消息积压处理办法：临时紧急扩容：**

**1、** 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。

**2、** 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。

**3、** 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。

**4、** 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。

**5、** 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。

**6、** MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。

**mq消息队列块满了：**

如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。


### 5、使用RabbitMQ有什么好处？

**1、** 解耦，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！

**2、** 异步，将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度

**3、** 削峰，并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常


### 6、RabbitMQ 允许发送的 message 最大可达多大？

根据 AMQP 协议规定，消息体的大小由 64-bit 的值来指定，所以你就可以知道到底能发多大的数据了。


### 7、RAM node 和 disk node 的区别？

RAM node 仅将 fabric（即 queue、exchange 和 binding 等 RabbitMQ 基础构件）相关元数据保存到内存中，但 disk node 会在内存和磁盘中均进行存储。RAM node 上唯一会存储到磁盘上的元数据是 cluster 中使用的 disk node 的地址。要求在 RabbitMQ cluster中至少存在一个 disk node 。


### 8、RabbitMQ是什么？

RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。


### 9、什么是Exchange交换器？

Exchange:生产者将消息发送到交换器，有交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。


### 10、RabbitMQ中消息可能有的几种状态?

**1、** alpha: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中 。

**2、** beta: 消息内容保存在磁盘中，消息索引保存在内存中。

**3、** gamma: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。

**4、** delta: 消息内容和索引都在磁盘中 。


### 11、vhost 是什么？起什么作用？
### 12、什么是RoutingKey路由键？
### 13、RabbitMQ如何实现延时队列?
### 14、AMQP是什么?
### 15、如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？
### 16、什么情况下会出现 blackholed 问题？
### 17、RabbitMQ消息是如何路由的？
### 18、什么是消费者Consumer?
### 19、如何确保消息接收方消费了消息?
### 20、如何避免消息重复投递或重复消费?
### 21、解耦、异步、削峰是什么？。
### 22、交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？
### 23、消息如何分发？
### 24、死信队列？
### 25、消息传输保证层级？
### 26、死信队列和延迟队列的使用?
### 27、如何解决RabbitMQ丢数据的问题?
### 28、RabbitMQ的集群模式有几种？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
